import datasets
import functools
import numpy as np
from sklearn.ensemble import BaggingClassifier
from keras.layers import *
from keras.layers.core import *
from keras.models import Sequential, Model
from keras.wrappers.scikit_learn import KerasClassifier


def build_model(nmeta_models=len(datasets.TRAINED_MODELS)):
    """Build neural net for stacked model.

    The constructed model takes as input data from the trained models and the original dataset,
    runs each through a single hidden layer with dropout, and merges the result into a final
    model that outputs classification results.

    This function returns the compiled model for later training/prediction.

    """
    meta = Sequential()
    meta.add(Dense(10, activation='relu', input_shape=(nmeta_models,)))
    meta.add(Dropout(0.5))

    orig_data = Sequential()
    orig_data.add(Dropout(0.5, input_shape=(1000,)))
    orig_data.add(Dense(30, activation='relu', kernel_regularizer=regularizers.l2(0.001)))
    orig_data.add(Dropout(0.5))

    merged = Merge([meta, orig_data], mode='concat')

    final_model = Sequential()
    final_model.add(merged)
    final_model.add(Dense(2, activation='softmax'))

    final_model.compile(loss='categorical_crossentropy',optimizer='adam', metrics=['accuracy'])
    return final_model


def train_bagged_nn(X_train, y_train, X_test, X_meta_train, X_meta_test, kf=datasets.KF_SEEDED,
        n_bags=10, verbose=False):
    """Use bagging on top of models generated by the build_model function to train a stacked model.

    Trains and evaluates a model based on provided data in X_train, y_train and other model results
    provided in X_meta_{train,test}, and returns the results of predictions on X_test.

    The model uses bagging on top of the neural nets from the build_model function to decrease
    variance in predictions.

    Returns numpy column vectors of results for each sample in X_train, X_test.

    """
    # initialize arrays to store results for each of the folds as we generate them
    classes_train = np.empty(y_train.shape)
    classes_test = np.empty(X_test.shape[0])

    def train_bagged_models(indices):
        """Train bagged models on the specific set of indices indicated.

        Returns the list of n_bags models.

        """
        models = []
        for bag in range(n_bags):
            if verbose:
                print('Bag %d' % bag)
            actual_indices = np.random.choice(indices, indices.shape[0])
            model = KerasClassifier(
                build_fn=functools.partial(build_model, nmeta_models=X_meta_train.shape[1]),
                epochs=50, batch_size=32, verbose=int(verbose))
            model.fit(
                [X_meta_train[actual_indices], X_train[actual_indices]],
                y_train[actual_indices])
            models.append(model)

        return models

    for split, (train_index, test_index) in enumerate(kf.split(X_train, y_train)):
        if verbose:
            print('Bagged NN, split=%d' % (split))
        models = train_bagged_models(train_index)
        raw_test_results = np.array([
            model.predict([X_meta_train[test_index], X_train[test_index]])
            for model in models])
        classes_train[test_index] = np.mean(raw_test_results, axis=0)
        if verbose:
            acc = (1 - np.sum(np.abs(np.rint(classes_train[test_index]) - y_train[test_index])) /
                    y_train.shape[0])
            print(f'Eval accuracy: {acc}')

    if verbose:
        print('NN, test')
    models = train_bagged_models(np.array(range(X_train.shape[0])))
    raw_test_results = np.array(
        [model.predict([X_meta_test, X_test]) for model in models])
    classes_test = np.mean(raw_test_results, axis=0)

    return classes_train, classes_test
